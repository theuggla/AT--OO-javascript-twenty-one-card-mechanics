<template id="windowTemplate">
    <style>
        :host {
            min-width: 30vw;
            min-height: 30vw;
            position: absolute;
            background-color: rgba(156, 141, 127, 0.56);
            border: solid black 5px;
            border-radius: 1em;
            border-image: url("/image/window.png") 10 8;
        }
        :host(:focus) {
            background-color: rgb(202, 187, 164);
        }
        :host([minimized]) {
            display: none;
        }
        a:visited {
            color: black;
        }
        a {
            text-decoration: none;
        }
        #bar {
            height: 10%;
            background-color: rgba(30, 27, 32, 0.74);
        }
        #menubar {
            height: 10%;
            background-color: white;
        }
        #content {
            border-radius: 1em;
        }
    </style>
    <div id="bar">
        <slot name="icon"></slot>
        <a href="" id="close">X</a>
        <a href="" id="minimize">-</a>
    </div>
    <div id="menubar">
        <slot name="menubar"></slot>
    </div>
    <div id="content">
        <slot name="content"></slot>
    </div>
</template>

<script>
    let windowTemplate = document.querySelector('link[href="/window.html"]').import.querySelector("#windowTemplate");

    customElements.define('draggable-window', class extends HTMLElement {
        constructor(type) {
            super();

            //setup shadow dom styles
            let shadowRoot = this.attachShadow({mode: "open"});
            let instance = windowTemplate.content.cloneNode(true);
            shadowRoot.appendChild(instance);
        }

        connectedCallback() {

            //set behaviour
            makeDraggable(this, this.parentNode);

            //add event listeners
            this.addEventListener("click", (event)=> {
                let target = event.composedPath()[0];
                let id = target.getAttribute("id");
                if (id === "close") {
                    this.close();
                } else if (id === "minimize") {
                    console.log("minimized");
                    this.minimized = true;
                }
                if (event.type === 'click') {
                    event.preventDefault();
                }
            });

            this.open = true;
        }

        get open() {
            return this.hasAttribute('open');
        }

        set open(open) {
            if (open) {
                this.setAttribute('open', '');
            } else {
                this.removeAttribute('open');
            }
        }

        get minimized() {
            return this.hasAttribute('minimized');
        }

        set minimized(minimize) {
            if (minimize) {
                this.setAttribute('minimized', '');
            } else {
                this.removeAttribute('minimized');
            }
        }

        close() {
            this.open = false;
            this.minimized = false;
            this.parentElement.removeChild(this);
        }

    });

    function makeDraggable(el, container) {
        let arrowDrag;
        let mouseDrag;
        let dragoffset = {
            x: 0,
            y: 0
        };

        let events = function() {
            addEventListeners(el, 'focusin mousedown touchmove', (function(event) {
                let target;
                if (event.type === 'touchmove') {
                    target = event.targetTouches[0];
                } else {
                    target = event;
                }
                arrowDrag = true;
                if (event.type === 'mousedown' || event.type === 'touchmove') {
                    mouseDrag = true;
                    dragoffset.x = target.pageX - el.offsetLeft;
                    dragoffset.y = target.pageY - el.offsetTop;
                }
            }));
            addEventListeners(el, 'focusout mouseup', (function() {
                if (event.type === 'mouseup') {
                    if (mouseDrag) {
                        mouseDrag = false;
                    }
                } else {
                    arrowDrag = false;
                }
            }));
            addEventListeners(document, 'mousemove keydown touchmove', ((event) => {
                let destination = {};

                if (mouseDrag) {
                    destination.y = (event.pageY - dragoffset.y);
                    destination.x = (event.pageX - dragoffset.x);
                } else if (arrowDrag) {
                    destination.y = parseInt(el.style.top.slice(0, -2));
                    destination.x = parseInt(el.style.left.slice(0, -2));

                    switch (event.key) {
                        case 'ArrowUp':
                            destination.y -= 5;
                            break;
                        case 'ArrowDown':
                            destination.y += 5;
                            break;
                        case 'ArrowLeft':
                            destination.x -= 5;
                            break;
                        case 'ArrowRight':
                            destination.x += 5;
                            break;
                    }
                }

                if (mouseDrag || arrowDrag) {
                    el.style.left = destination.x  + "px";
                    el.style.top = destination.y  + "px";
                }

            }));
        };

        el.style.position = "absolute";
        events();
    }

    function addEventListeners(element, events, handler) {
        events.split(' ').forEach(event => element.addEventListener(event, handler));
    }
</script>
